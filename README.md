## Object 를 공부하며 느낀 점 정리
[Chapter 1](#Chapter-1)

# Chapter 1

Theme1
- 비지니스 로직을 객체들의 상호작용임을 고려하면서 class를 작성하는게 인상깊음
  => 특히 class의 상호작용을 위한 class를 만드는게 인상깊음
- 생성자를 만들때 매개변수를 모두 고려한 생성자를 밑에 두고 위에 매개변수의 일부만을 사용하는 생성자를 만들면서
  This(null, 입력받은 매개변수) 형식으로 호출하는 것이 인상깊음
- 가변인자 … 는 내부적으로 배열 객체를 형성함 => 향상된 for문 사용가능

Theme2
- module(크기와 상관없이 클래스, 패키지, 라이브러리와 같은 프로그램을 구성하는 임의의 요소)
  의 3가지 기능 -> 1. 실행 중에 제대로 동작 2. 변경을 위해 존재(변경의 용이성) 3. 코드를 읽는 사람과의 의사소통
- 초기의 코드는 각 클래스들이 서로의 내부에 너무 깊게 관여해있다(결합도가 높다). 즉 객체 사이의 의존성이 크다. 따라서 특정 객체에 대한 변경이 부담스럽다. => 기능을 단순히 나누어서 각 객체들에 나누어 담는 것 만으로는 객체지향 설계가 아님 -> 불필요한 의존성을 제거할 필요가 있다, 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성할 필요가 있다(인터페이스 - 구현)
- 불필요한 의존성을 제거하는 방법
    1. 객체의 자율성을 높이자
       -> 어떤 객체에 대한 접근제한을 특정 객체로 제한함으로써 어떤 객체에 대한 접근은 오직 특정 객체에 의해서만 가능하게 되고 이는 특정 객체가 스스로 어떤 일을 수행해야 함을 의미
       -> 캡슐화 : 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것(객체 내부로의 접근을 제한)
       =자기 문제를 스스로 해결하도록 코드를 수정 = 응집도를 높임(연관성 없는 작업을 다른 객체에 위임)

수정 전 => 절차적 프로그래밍, 프로세스(기능)는 특정 객체에서만 담당하고 나머지 객체들은 데이터의 역할을 수행
= 데이터와 프로세스가 동일한 모듈 내부에 있지 않음
수정 후 => 객체지향 프로그래밍, 각 객체가 자신의 데이터에 대해서 스스로 처리함, 객체 간에는 소통
= 데이터와 프로세스가 동일한 모듈 내부에 위치함

### 객체지향의 세계에서는 모든 것이 능동적이고 자율적인 존재이다 -> 의인화

# Chapter2 / 객체지향 구현

Theme1

- 객체지향은 클래스가 아닌 객체에 초점을 맞추고 설계해야 한다
  -> 클래스란 결국 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것에 불과하다

- 도메인
  -> 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 -> 웹개발에서는 비지니스 로직에 해당한다고 보면 됨
  -> 도메인 모델을 형성해봄으로써 어떤 객체가 필요하고 서로 상호작용하는지 구상한 후에 구현을 한다

- 클래스 접근제어
  -> 객체의 속성에는 직접 접근할 수 없도록 막고 적절한 public메서드를 통해서만 내부 상태를 변경할 수 있게 해야함
  -> 경계의 명확성이 자율성을 보장

- 추상클래스, 인터페이스를 처음 써 봄
  -> 영화의 두 가지 할인정책을 만약 나에게 구현하라고 했으면 int discountPolicy = 0 or 1 로 해서 매개변수로 간단하게 구분하고 메서드 내에서 if문으로 0,1일때 각각을 계산하게 했을 것 같다. 하지만 discountPolicy를 상속하는 두 클래스를 만들어 내부에서 계산도 처리하도록 클래스를 만드니까 코드가 훨씬 보기 편하고 아름답다고 느낀다. 매우 인상깊다

Theme2

- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다 -> 코드 수준에서는 인터페이스에 의존, 실행 시점에서는 인터페이스를 구현한 특정 인스턴스에 의존 -> 유연성, 확장가능성 = 다형성 하지만 디버깅 등이 어렵다 (트레이드오프)
- 다형성의 핵심은 동적 바인딩에 있다. 즉, 메시지와 메서드를 런타임 시점에서 바인딩 하는 것이다. 이는 컴파일 시점의 의존성과 런타인 시점의 의존성을 분리하는 지연(동적) 바인딩 메커니즘에 의해 이루어진다.
- 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택 => 예를 들어 할인 정책이 없는 영화의 경우 Movie 객체 내부에서 if문을 통해 할인 정책이 없을 경우 영화Fee를 그대로 반환하도록 한다고 하자. 이렇게 되면 영화의 할인을 계산하는 역할을 DiscountPolicy클래스에 위임했던 일관성이 무너진다. 따라서 이런 if else문의 남용을 주의하자! 매우 인상깊음

Theme3

- 상속은 코드 재사용을 위해 널리 사용되는 기법이지만 두 가지 관점에서 설계에 좋지 않은 영향을 끼침
    1. 캡슐화 위반 -> 부모 클래스의 내부 구조를 잘 알아야 함
       2.설계가 유연하지 않음 -> 실행 시점에 객체의 종류를 변경하는 것이 불가능하다
- 이 단점을 해결하는 코드 재사용 방법은 합성 -> 객체 내부에 객체의 인스턴스를 사용해서 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다

# Chapter3 / 객체지향 패러다임의 본질 (역할, 책임, 협력)

Theme1
- 협력은 시스템이 제공해야할 기능적 문맥을 의미한다
- 역할이란 대체 가능한 책임들이 모여 형성된다 => 큰 범위의 역할에 대해 슬롯처럼 책임들을 교체할 수 있다 = 다형성
- 책임이란 협력에 참여하기 위해 객체가 수행하는 행동을 의미한다 -> 하는 것, 아는 것
  => 책임은 해당 책임을 수행하는데 있어 필요한 정보를 많이 가지고 있는 ‘정보전문가’에게 할당하는것이 바람직하다
- 객체가 메시지를 결정하는 것이 아니라 메시지가 객체를 결정한다
- 객체의 행동이 상태를 결정한다. 객체의 상태는 결국 행동을 위한 재료에 불과하다
- 객체는 다양한 역할을 가질 수 있다. 이때 하나의 협력에서 하나의 객체는 하나의 역할로 보여진다. 협력의 관점에서는 동일한 역할을 수행하는 객체들은 서로 대체가능하다(다형성). 역할은 특정한 객체의 종류를 캡슐화 한다.(해당 역할을 수행할 수 있다는 정보만 가질 뿐 해당 객체의 세부 구현을 알지는 못한다.)

# Chapter4 / 설계품질과 트레이드오프(책임 중심 설계와 데이터 중심 설계를 비교하며)

Theme1
- 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다

Theme2
- 캡슐화, 응집도, 결합도 세 가지 기준으로 책임 중심 설계와 데이터 중심 설계를 비교
  -> 캡슐화 : 객체지향 설계가 널리 쓰이는 이유는 변경에 대한 파급효과를 조절할 수 있기 때문이다
  변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개한다.
  변경 가능성이 높은 부분을 ‘구현’, 상대적으로 안정적인 부분을 ‘인터페이스’라고 한다.
  -> 응집도 : 높을 수록 한 모듈의 변경에 대한 파급효과가 적다
  -> 결합도 : 높을 수록 한 모듈의 변경에 대한 파급효과가 크다
- 데이터 중심 설계의 문제점 : 캡슐화 위반(객체의 내부 구현을 인터페이스의 일부로 만듬), 높은 결합도, 낮은 응집도
  ex) Movie클래스에서는 퍼블릭 메서드를 통해서만 내부 상태에 접근 가능 -> 이건 캡슐화가 아니다! 퍼블릭 인터페이스에 Movie 내부에 Money 타입의 fee 인스턴스 변수가 존재함을 드러내기 때문이다.
- 결국 데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 변경에 매우 취약해진다


# Chapter5 / 책임 주도 설계를 향해

Theme1
- 데이터 중심 설계에서 책임 중심의 설계로의 전환 : 1.데이터보다 행동을 먼저 결정 2. 협력이라는 문맥 안에서 책임을 결정
- 시스템 책임 파악 -> 책임 분할 -> 책임 할당 -> 다른 객체의 도움이 필요한 경우 적절한 역할 설정 -> 책임 할당(협력)
- 최초 메시지(클라이언트의 요구) -> 메시지 수신 객체 설정 -> 책임에 필요한 데이터는 무엇인가? -> 자신이 수행 할 수 없는 책임 -> 메시지 송신 -> 반복
- 메시지는 송신자의 의도를 반영해야 한다 = 수신자의 구현에 대해 고려하지 않음(캡슐화)
- 서로 다른 이유로 변경되는 두 개의 메서드를 가진다 = 응집도가 낮다
  -> 응집도가 낮은 클래스의 특징 : 클래스의 속성이 서로 다른 시점에 초기화 되거나 일부만 초기화 됨
  -> 메서드들이 사용하는 속성에 따라 그룹이 나뉨
- GRASP패턴
  -> 낮은 결합도, 높은 응집도
  -> 정보전문가
  -> 도메인 모델
  -> 창조자 패턴 : 객체A를 생성하는 책임을 객체B에게 맡긴다. -> B: A객체를 포함 또는 참조, 기록, 사용, A객체를
  초기화 하는데 필요한 데이터 지님

Theme2
- 하지만 처음부터 적절한 책임을 적절한 객체에게 부여하는 것은 쉽지 않다 -> 선구현(실행에 목적) 후에 리팩터링을 통해 내부구조를 변경한다.
- chapter4에서 데이터 중심으로 설계한 코드를 리팩터링 하는 과정을 통해 리팩터링이 어떻게 진행되는지 알아본다

# Chapter 6 / 메시지와 인터페이스

Theme1
- 객체지향의 가장 큰 오해 -> 애플리케이션은 클래스의 집합으로 구성된다. -> 하지만 클래스는 도구일 뿐이다.
- 훌륭한 객체지향 코드는 클래스가 아니라 객체를 지향해야 한다. 협력 안에서 객체가 수행하는 책임에 집중한다.
- 객체지향의 가장 중요한 재료는 클래스가 아니라 메시지이다. -> 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환하는 능력을 길러야 한다.
- 이번 장에서는 객체들이 수신하는 메시지들이 구성하는 퍼블릭 인터페이스를 만드는데 도움이 되는 설계 원칙과 기법을 연마한다.

Theme2
- 클라이언트-서버 모델 : 클라이언트 = 요청, 서버 = 기능(수행)
- 오퍼레이션은 어떠한 수행에 대한 추상화된 메시지를 의미하고, 그 오퍼레이션에 대한 구현을 메서드라한다.
  즉, 한 오퍼레이션에 대해 여러 메서드가 있을 수 있다. -> 다형성
- 오퍼레이션은 시그니처만(이름, 인자)을 가지는데, 오퍼레이션의 집합을 퍼블릭 인터페이스라고 한다.
- 퍼블릭 인터페이스와 관련된 원칙과 기법 : 디미터 법칙, 명령-쿼리 분리
  -> 디미터 법칙 : 하나의 도트만 사용하라 -> 객체들의 협력경로 제한 -> 결합도 낮춤
  지나친 수용은 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있음
  -> 이때 디미터 법칙에 대한 오해 : 하나의 . 만을 사용한다 -> 캡슐화의 관점에서 접근해야 한다. 만약 같은 인스턴스	를 계속해서 반환하는 . chain(기차충돌)은 디미터 법칙을 위배한 것이 아니다. 특정 객체의 내부 구조를 내부에서
  계속 사용하는 것이기 때문에 객체의 내부 구조가 외부로 노출되는 경우가 아니기 때문이다. 매우 중요
  -> 묻지 말고 시켜라 : 객체의 상태를 물어본 후 반환값을 기반으로 결정을 내리고, 결정에 따라 객체의 상태를
  변경하는 코드는 묻지말고 시켜라 스타일로 변경해야한다.
  -> 가끔씩은 물을 필요도 있다! 결합도와 응집도 사이에서 트레이드오프를 고려하자

  -> 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈 = 루틴 -> 프로시저, 함수
  프로시저 : 내부 상태 변경 = 명령 : 객체의 상태 수정하는 오퍼레이션
  함수 : 값을 계산해서 반환 = 쿼리 : 객체와 관련된 정보 반환하는 오퍼레이션
  -> 명령-쿼리 분리 : 질문이 답변을 수정해서는 안 된다.
- 메서드의 명명은 어떻게가 아니라 무엇을에 초점을 맞춘다. 즉, 구현방법이 아니라 클라이언트의 의도를 드러내야한다.
  클라이언트가 객체에게 무엇을 원하는지를 명확하게 표현해야 한다.

# Chapter7 / 객체 분해

Theme1
- 추상화와 분해는 복잡한 문제를 해결하기 위해 사용할 수 있는 가장 강력한 도구이다.
- 추상화는 기능과 데이터의 관점으로 나뉜다. 프로그래밍 패러다임은 먼저 기능의 추상화의 손을 들었다
- 기능 분해(알고리즘 분해)는 시스템을 더 작은 작업으로 분해될 수 있는 커다란 메인 함수로 보고 하향식 접근법으로 더 구체적인 하위 단계로 분해해 나간다. -> 이 방식의 유지보수 관점에서의 문제점을 살펴보며 객체지향의 장점을 이해하자

Theme2
- 급여 관리 시스템을 기능 분해로 구현
  -> 수도 코드로 진행해서 따로 java 코드는 없음
  -> 메인 함수를 루트로 하는 트리로 표현된다. 각 노드는 시스템을 구성하는 하나의 프로시저
  -> 문제점 : 시스템으 하나의 메인함수가 아니다, 기능 추가 등으로 메인 함수를 빈번하게 수정해야 한다, 비지니스 로직이 사용자 인터페이스와 강하게 결합된다, 유연성과 재사용성 저하, 데이터 형식 변경의 파급효과 예측 불가능
  -> 현대 시스템은 동등한 수준의 다양한 기능으로 구성된다! 인상깊음
  -> 결국 모든 문제의 원인은 결합도이다
    - 함수는 상위 함수의 문맥에 강하게 결합됨
    - 함수는 다른 함수들과 시간적으로 강하게 결합됨
    - 강한 결합도는 시스템을 변경에 취약하고, 이해하기 어렵게 마듬
    - 사소한 변경이 시스템 전체를 흔들 수 있음

Theme3
- 이론적인 내용 -> 책 참조
- 역사적인 내용(객체 기반 프로그래밍 -> 객체 지향 프로그래밍)
- 추상 데이터 타입은 오퍼레이션을 기준으로 타입을 묶는다
- 객체지향은 타입을 기준으로 오퍼레이션을 묶는다 -> 인스턴스 변수의 값을 기반으로 메서드 내에서 같은 객체이더라도 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것이다. Ex) Student.class == 1 -> 중학생, 2 == 고등학생
- 타입의 추가가 잦은 경우는 객체지향의 클래스 구조가, 새로운 오퍼레이션의 추가가 잦은 경우는 추상 데이터 타입이 유리

# Chapter 8 / 의존성

Theme1
- 의존성은 변경의 파급효과가 미칠 수 있음을 의미한다
- 의존성 전이로 인해 직접 의존성이 없더라도 간접 의존성으로 변경의 파급효과가 미칠 수 있다
- 객체지향설계는 변경의 파급효과를 유연하게 관리하고 제어할 수 있어야 하므로 의존성의 관리가 중요하다
- 의존성은 런타임 의존성과 컴파일 의존성으로 나뉜다.(시점의 차이 : 런타임 = 객체, 컴파일 타임 = 클래스)
- 다형성을 적용한 객체의 경우 어떤 객체가 컴파일 타임에 특정 인터페이스에 의존성이 있고, 그 인터페이스를 구현한 클래스에는 의존성이 없다. 하지만 런타임에는 구현한 클래스 중 하나가 객체에게 전달되어 런타임에는 의존성이 있다.

Theme2
- 이 책에서 계속 강조하는 부분인데 유연하고 확장 가능한 설계를 만들기 위해서는 컴파일 타임 의존성과 런타임 의존성이 달라야 한다. 처음 자바를 공부할 때만 해도 인터페이스나 추상클래스가 어떻게 이용되고, 왜 필요한지 의문이 많았는데 실제 프로그래밍에 유용하게 활용할 수 있을 것 같다.
- 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성이다.
- 결합도가 높을 수록 강한 의존성을 가지게 된다. 강한 의존성은 여러 컨텍스트에서 객체가 재사용되는 것을 제한한다. 따라서 높은 결합도를 주의해야하는데 더 많이 알수록 더 많이 결합된다는 사실에 기반해서 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다. 즉, 추상화가 중요하다.
- 구체 클래스 의존성 > 추상 클래스 의존성 > 인터페이스 의존성 -> 우측으로 갈수록 결합도가 느슨해진다
- 사용과 생성의 책임을 분리하면 결합도를 낮추어 설계를 유연하게 만들 수 있다 -> 객체 내에서 필요한 인터페이스를 직접 생성하는 것을 피하고, 생성자나 setter로 받는다.
- ### 하지만 설계는 언제나 트레이드오프의 연속이라는 사실이 중요핟! 따라서 결합도와 사용성 사이에서 중요도를 잘 파악해서 프로그래밍 하는게 중요하다!
- List<type> variable = new ArrayList(); 로 받는 이유가 항상 궁금했는데 이는 인스턴스를 직접 생성하더라도 최대한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하기 때문이다!
- 유연하고 재사용 가능한 설계는 응집도 높은 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.
 		
