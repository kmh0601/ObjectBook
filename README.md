Object 를 공부하며 느낀 점 정리
====
---
[Chapter 1](#Chapter-1)  
[Chapter 2](#Chapter-2)  
[Chapter 3](#Chapter-3)  
[Chapter 4](#Chapter-4)  
[Chapter 5](#Chapter-5)  
[Chapter 6](#Chapter-6)  
[Chapter 7](#Chapter-7)  
[Chapter 8](#Chapter-8)  
[Chapter 9](#chapter-9)  
[Chapter 10](#chapter-10)  
[Chapter 11](#chapter-11)  
[Chapter 12⭐️](#chapter12---다형성-)

---
# Chapter 1

>Theme1
- 비지니스 로직을 객체들의 상호작용임을 고려하면서 class를 작성하는게 인상깊음
  => 특히 class의 상호작용을 위한 class를 만드는게 인상깊음
- 생성자를 만들때 매개변수를 모두 고려한 생성자를 밑에 두고 위에 매개변수의 일부만을 사용하는 생성자를 만들면서
  This(null, 입력받은 매개변수) 형식으로 호출하는 것이 인상깊음
- 가변인자 … 는 내부적으로 배열 객체를 형성함 => 향상된 for문 사용가능

>Theme2
- module(크기와 상관없이 클래스, 패키지, 라이브러리와 같은 프로그램을 구성하는 임의의 요소)
  의 3가지 기능 -> 1. 실행 중에 제대로 동작 2. 변경을 위해 존재(변경의 용이성) 3. 코드를 읽는 사람과의 의사소통
- 초기의 코드는 각 클래스들이 서로의 내부에 너무 깊게 관여해있다(결합도가 높다). 즉 객체 사이의 의존성이 크다. 따라서 특정 객체에 대한 변경이 부담스럽다. => 기능을 단순히 나누어서 각 객체들에 나누어 담는 것 만으로는 객체지향 설계가 아님 -> 불필요한 의존성을 제거할 필요가 있다, 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성할 필요가 있다(인터페이스 - 구현)
- 불필요한 의존성을 제거하는 방법
  - 객체의 자율성을 높이자
       -> 어떤 객체에 대한 접근제한을 특정 객체로 제한함으로써 어떤 객체에 대한 접근은 오직 특정 객체에 의해서만 가능하게 되고 이는 특정 객체가 스스로 어떤 일을 수행해야 함을 의미
       -> 캡슐화 : 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것(객체 내부로의 접근을 제한)
       =자기 문제를 스스로 해결하도록 코드를 수정 = 응집도를 높임(연관성 없는 작업을 다른 객체에 위임)

수정 전 => 절차적 프로그래밍, 프로세스(기능)는 특정 객체에서만 담당하고 나머지 객체들은 데이터의 역할을 수행
= 데이터와 프로세스가 동일한 모듈 내부에 있지 않음
수정 후 => 객체지향 프로그래밍, 각 객체가 자신의 데이터에 대해서 스스로 처리함, 객체 간에는 소통
= 데이터와 프로세스가 동일한 모듈 내부에 위치함

>객체지향의 세계에서는 모든 것이 능동적이고 자율적인 존재이다 -> 의인화

# Chapter 2
- 객체지향 구현

>Theme1

- 객체지향은 클래스가 아닌 객체에 초점을 맞추고 설계해야 한다
  -> 클래스란 결국 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것에 불과하다

- 도메인
  -> 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 -> 웹개발에서는 비지니스 로직에 해당한다고 보면 됨
  -> 도메인 모델을 형성해봄으로써 어떤 객체가 필요하고 서로 상호작용하는지 구상한 후에 구현을 한다

- 클래스 접근제어
  -> 객체의 속성에는 직접 접근할 수 없도록 막고 적절한 public메서드를 통해서만 내부 상태를 변경할 수 있게 해야함
  -> 경계의 명확성이 자율성을 보장

- 추상클래스, 인터페이스를 처음 써 봄
  -> 영화의 두 가지 할인정책을 만약 나에게 구현하라고 했으면 int discountPolicy = 0 or 1 로 해서 매개변수로 간단하게 구분하고 메서드 내에서 if문으로 0,1일때 각각을 계산하게 했을 것 같다. 하지만 discountPolicy를 상속하는 두 클래스를 만들어 내부에서 계산도 처리하도록 클래스를 만드니까 코드가 훨씬 보기 편하고 아름답다고 느낀다. 매우 인상깊다

>Theme2

- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다 -> 코드 수준에서는 인터페이스에 의존, 실행 시점에서는 인터페이스를 구현한 특정 인스턴스에 의존 -> 유연성, 확장가능성 = 다형성 하지만 디버깅 등이 어렵다 (트레이드오프)
- 다형성의 핵심은 동적 바인딩에 있다. 즉, 메시지와 메서드를 런타임 시점에서 바인딩 하는 것이다. 이는 컴파일 시점의 의존성과 런타인 시점의 의존성을 분리하는 지연(동적) 바인딩 메커니즘에 의해 이루어진다.
- 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택 => 예를 들어 할인 정책이 없는 영화의 경우 Movie 객체 내부에서 if문을 통해 할인 정책이 없을 경우 영화Fee를 그대로 반환하도록 한다고 하자. 이렇게 되면 영화의 할인을 계산하는 역할을 DiscountPolicy클래스에 위임했던 일관성이 무너진다. 따라서 이런 if else문의 남용을 주의하자! 매우 인상깊음

>Theme3

- 상속은 코드 재사용을 위해 널리 사용되는 기법이지만 두 가지 관점에서 설계에 좋지 않은 영향을 끼침
  1. 캡슐화 위반 -> 부모 클래스의 내부 구조를 잘 알아야 함
     2.설계가 유연하지 않음 -> 실행 시점에 객체의 종류를 변경하는 것이 불가능하다
- 이 단점을 해결하는 코드 재사용 방법은 합성 -> 객체 내부에 객체의 인스턴스를 사용해서 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다

# Chapter 3
- 객체지향 패러다임의 본질 (역할, 책임, 협력)

>Theme1
- 협력은 시스템이 제공해야할 기능적 문맥을 의미한다
- 역할이란 대체 가능한 책임들이 모여 형성된다 => 큰 범위의 역할에 대해 슬롯처럼 책임들을 교체할 수 있다 = 다형성
- 책임이란 협력에 참여하기 위해 객체가 수행하는 행동을 의미한다 -> 하는 것, 아는 것
  => 책임은 해당 책임을 수행하는데 있어 필요한 정보를 많이 가지고 있는 ‘정보전문가’에게 할당하는것이 바람직하다
- 객체가 메시지를 결정하는 것이 아니라 메시지가 객체를 결정한다
- 객체의 행동이 상태를 결정한다. 객체의 상태는 결국 행동을 위한 재료에 불과하다
- 객체는 다양한 역할을 가질 수 있다. 이때 하나의 협력에서 하나의 객체는 하나의 역할로 보여진다. 협력의 관점에서는 동일한 역할을 수행하는 객체들은 서로 대체가능하다(다형성). 역할은 특정한 객체의 종류를 캡슐화 한다.(해당 역할을 수행할 수 있다는 정보만 가질 뿐 해당 객체의 세부 구현을 알지는 못한다.)

# Chapter 4
- 설계품질과 트레이드오프(책임 중심 설계와 데이터 중심 설계를 비교하며)

>Theme1
- 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다

>Theme2
- 캡슐화, 응집도, 결합도 세 가지 기준으로 책임 중심 설계와 데이터 중심 설계를 비교
  -> 캡슐화 : 객체지향 설계가 널리 쓰이는 이유는 변경에 대한 파급효과를 조절할 수 있기 때문이다
  변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개한다.
  변경 가능성이 높은 부분을 ‘구현’, 상대적으로 안정적인 부분을 ‘인터페이스’라고 한다.
  -> 응집도 : 높을 수록 한 모듈의 변경에 대한 파급효과가 적다
  -> 결합도 : 높을 수록 한 모듈의 변경에 대한 파급효과가 크다
- 데이터 중심 설계의 문제점 : 캡슐화 위반(객체의 내부 구현을 인터페이스의 일부로 만듬), 높은 결합도, 낮은 응집도
  ex) Movie클래스에서는 퍼블릭 메서드를 통해서만 내부 상태에 접근 가능 -> 이건 캡슐화가 아니다! 퍼블릭 인터페이스에 Movie 내부에 Money 타입의 fee 인스턴스 변수가 존재함을 드러내기 때문이다.
- 결국 데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 변경에 매우 취약해진다


# Chapter 5
- 책임 주도 설계를 향해

>Theme1
- 데이터 중심 설계에서 책임 중심의 설계로의 전환 : 1.데이터보다 행동을 먼저 결정 2. 협력이라는 문맥 안에서 책임을 결정
- 시스템 책임 파악 -> 책임 분할 -> 책임 할당 -> 다른 객체의 도움이 필요한 경우 적절한 역할 설정 -> 책임 할당(협력)
- 최초 메시지(클라이언트의 요구) -> 메시지 수신 객체 설정 -> 책임에 필요한 데이터는 무엇인가? -> 자신이 수행 할 수 없는 책임 -> 메시지 송신 -> 반복
- 메시지는 송신자의 의도를 반영해야 한다 = 수신자의 구현에 대해 고려하지 않음(캡슐화)
- 서로 다른 이유로 변경되는 두 개의 메서드를 가진다 = 응집도가 낮다
  -> 응집도가 낮은 클래스의 특징 : 클래스의 속성이 서로 다른 시점에 초기화 되거나 일부만 초기화 됨
  -> 메서드들이 사용하는 속성에 따라 그룹이 나뉨
- GRASP패턴
  -> 낮은 결합도, 높은 응집도
  -> 정보전문가
  -> 도메인 모델
  -> 창조자 패턴 : 객체A를 생성하는 책임을 객체B에게 맡긴다. -> B: A객체를 포함 또는 참조, 기록, 사용, A객체를
  초기화 하는데 필요한 데이터 지님

>Theme2
- 하지만 처음부터 적절한 책임을 적절한 객체에게 부여하는 것은 쉽지 않다 -> 선구현(실행에 목적) 후에 리팩터링을 통해 내부구조를 변경한다.
- chapter4에서 데이터 중심으로 설계한 코드를 리팩터링 하는 과정을 통해 리팩터링이 어떻게 진행되는지 알아본다

# Chapter 6
- 메시지와 인터페이스

>Theme1
- 객체지향의 가장 큰 오해 -> 애플리케이션은 클래스의 집합으로 구성된다. -> 하지만 클래스는 도구일 뿐이다.
- 훌륭한 객체지향 코드는 클래스가 아니라 객체를 지향해야 한다. 협력 안에서 객체가 수행하는 책임에 집중한다.
- 객체지향의 가장 중요한 재료는 클래스가 아니라 메시지이다. -> 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환하는 능력을 길러야 한다.
- 이번 장에서는 객체들이 수신하는 메시지들이 구성하는 퍼블릭 인터페이스를 만드는데 도움이 되는 설계 원칙과 기법을 연마한다.

>Theme2
- 클라이언트-서버 모델 : 클라이언트 = 요청, 서버 = 기능(수행)
- 오퍼레이션은 어떠한 수행에 대한 추상화된 메시지를 의미하고, 그 오퍼레이션에 대한 구현을 메서드라한다.
  즉, 한 오퍼레이션에 대해 여러 메서드가 있을 수 있다. -> 다형성
- 오퍼레이션은 시그니처만(이름, 인자)을 가지는데, 오퍼레이션의 집합을 퍼블릭 인터페이스라고 한다.
- 퍼블릭 인터페이스와 관련된 원칙과 기법 : 디미터 법칙, 명령-쿼리 분리
  -> 디미터 법칙 : 하나의 도트만 사용하라 -> 객체들의 협력경로 제한 -> 결합도 낮춤
  지나친 수용은 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있음
  -> 이때 디미터 법칙에 대한 오해 : 하나의 . 만을 사용한다 -> 캡슐화의 관점에서 접근해야 한다. 만약 같은 인스턴스	를 계속해서 반환하는 . chain(기차충돌)은 디미터 법칙을 위배한 것이 아니다. 특정 객체의 내부 구조를 내부에서
  계속 사용하는 것이기 때문에 객체의 내부 구조가 외부로 노출되는 경우가 아니기 때문이다. 매우 중요
  -> 묻지 말고 시켜라 : 객체의 상태를 물어본 후 반환값을 기반으로 결정을 내리고, 결정에 따라 객체의 상태를
  변경하는 코드는 묻지말고 시켜라 스타일로 변경해야한다.
  -> 가끔씩은 물을 필요도 있다! 결합도와 응집도 사이에서 트레이드오프를 고려하자

  -> 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈 = 루틴 -> 프로시저, 함수
  프로시저 : 내부 상태 변경 = 명령 : 객체의 상태 수정하는 오퍼레이션
  함수 : 값을 계산해서 반환 = 쿼리 : 객체와 관련된 정보 반환하는 오퍼레이션
  -> 명령-쿼리 분리 : 질문이 답변을 수정해서는 안 된다.
- 메서드의 명명은 어떻게가 아니라 무엇을에 초점을 맞춘다. 즉, 구현방법이 아니라 클라이언트의 의도를 드러내야한다.
  클라이언트가 객체에게 무엇을 원하는지를 명확하게 표현해야 한다.

# Chapter 7
- 객체 분해

>Theme1
- 추상화와 분해는 복잡한 문제를 해결하기 위해 사용할 수 있는 가장 강력한 도구이다.
- 추상화는 기능과 데이터의 관점으로 나뉜다. 프로그래밍 패러다임은 먼저 기능의 추상화의 손을 들었다
- 기능 분해(알고리즘 분해)는 시스템을 더 작은 작업으로 분해될 수 있는 커다란 메인 함수로 보고 하향식 접근법으로 더 구체적인 하위 단계로 분해해 나간다. -> 이 방식의 유지보수 관점에서의 문제점을 살펴보며 객체지향의 장점을 이해하자

>Theme2
- 급여 관리 시스템을 기능 분해로 구현
  -> 수도 코드로 진행해서 따로 java 코드는 없음
  -> 메인 함수를 루트로 하는 트리로 표현된다. 각 노드는 시스템을 구성하는 하나의 프로시저
  -> 문제점 : 시스템으 하나의 메인함수가 아니다, 기능 추가 등으로 메인 함수를 빈번하게 수정해야 한다, 비지니스 로직이 사용자 인터페이스와 강하게 결합된다, 유연성과 재사용성 저하, 데이터 형식 변경의 파급효과 예측 불가능
  -> 현대 시스템은 동등한 수준의 다양한 기능으로 구성된다! 인상깊음
  -> 결국 모든 문제의 원인은 결합도이다
  - 함수는 상위 함수의 문맥에 강하게 결합됨
  - 함수는 다른 함수들과 시간적으로 강하게 결합됨
  - 강한 결합도는 시스템을 변경에 취약하고, 이해하기 어렵게 마듬
  - 사소한 변경이 시스템 전체를 흔들 수 있음

>Theme3
- 이론적인 내용 -> 책 참조
- 역사적인 내용(객체 기반 프로그래밍 -> 객체 지향 프로그래밍)
- 추상 데이터 타입은 오퍼레이션을 기준으로 타입을 묶는다
- 객체지향은 타입을 기준으로 오퍼레이션을 묶는다 -> 인스턴스 변수의 값을 기반으로 메서드 내에서 같은 객체이더라도 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것이다. Ex) Student.class == 1 -> 중학생, 2 == 고등학생
- 타입의 추가가 잦은 경우는 객체지향의 클래스 구조가, 새로운 오퍼레이션의 추가가 잦은 경우는 추상 데이터 타입이 유리

# Chapter 8
- 의존성

>Theme1
- 의존성은 변경의 파급효과가 미칠 수 있음을 의미한다
- 의존성 전이로 인해 직접 의존성이 없더라도 간접 의존성으로 변경의 파급효과가 미칠 수 있다
- 객체지향설계는 변경의 파급효과를 유연하게 관리하고 제어할 수 있어야 하므로 의존성의 관리가 중요하다
- 의존성은 런타임 의존성과 컴파일 의존성으로 나뉜다.(시점의 차이 : 런타임 = 객체, 컴파일 타임 = 클래스)
- 다형성을 적용한 객체의 경우 어떤 객체가 컴파일 타임에 특정 인터페이스에 의존성이 있고, 그 인터페이스를 구현한 클래스에는 의존성이 없다. 하지만 런타임에는 구현한 클래스 중 하나가 객체에게 전달되어 런타임에는 의존성이 있다.

>Theme2
- 이 책에서 계속 강조하는 부분인데 유연하고 확장 가능한 설계를 만들기 위해서는 컴파일 타임 의존성과 런타임 의존성이 달라야 한다. 처음 자바를 공부할 때만 해도 인터페이스나 추상클래스가 어떻게 이용되고, 왜 필요한지 의문이 많았는데 실제 프로그래밍에 유용하게 활용할 수 있을 것 같다.
- 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성이다.
- 결합도가 높을 수록 강한 의존성을 가지게 된다. 강한 의존성은 여러 컨텍스트에서 객체가 재사용되는 것을 제한한다. 따라서 높은 결합도를 주의해야하는데 더 많이 알수록 더 많이 결합된다는 사실에 기반해서 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다. 즉, 추상화가 중요하다.
- 구체 클래스 의존성 > 추상 클래스 의존성 > 인터페이스 의존성 -> 우측으로 갈수록 결합도가 느슨해진다
- 사용과 생성의 책임을 분리하면 결합도를 낮추어 설계를 유연하게 만들 수 있다 -> 객체 내에서 필요한 인터페이스를 직접 생성하는 것을 피하고, 생성자나 setter로 받는다.
>하지만 설계는 언제나 트레이드오프의 연속이라는 사실이 중요하다! <br/>
>따라서 결합도와 사용성 사이에서 중요도를 잘 파악해서 프로그래밍 하는게 중요하다!
- List\<type> variable = new ArrayList(); 로 받는 이유가 항상 궁금했는데 이는 인스턴스를 직접 생성하더라도 최대한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하기 때문이다!
- 유연하고 재사용 가능한 설계는 응집도 높은 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.

# Chapter 9
- chapter8에서 공부한 기법들을 원칙의 관점에서 정리

>Theme1
- 개방-폐쇄 원칙 : 소프트웨어 개체들은 확장에 대해서는 열려 있고, 수정에 대해서는 닫혀 있어야 한다.
- 즉, 기존 코드의 수정없이도 유연한 확장이 가능해야 함을 의미한다
- 이는 컴파일타임 의존성과 런타임 의존성의 구분을 통해 구현된다
- 우리는 Movie 클래스가 DiscountPolicy에 컴파일타임 의존성을 가지게 하고, AmountDiscountPolicy, PercentDiscountPolicy를 각각 상속하여 구현해 런타임 의존성을 갖게 함으로써 후에 OverlappedDiscountPolicy를 컴파일타임 의존성의 수정 없이도 추가해서 기능을 확장할 수 있었다!!
- 생성과 사용의 분리 : 객체를 사용하는 책임과 객체를 생성하는 책임을 분리해야 한다
- 클라이언트와 서버와 같다. 객체를 생성하는 것은 클라이언트, 사용하는 것은 서버이다
- 이때 클라이언트로 부터 생성의 책임을 옮기는 것이 좋은데, 이때 사용되는 것이 객체 생성에 특화된 객체인 FACTORY라고 한다. (스프링부트 공부할때 들어본 적 있다!)
- 결국 Client는 사용과 관련된 책임만, FACTORY는 생성관 관련된 책임을 진다.
```java
public class Client{
	private Factory factory;
	
	public Client(Factory factory){
		this.factory = factory;
	}
	
	public Money getFee(){
		Movie anything = factory.createMovie(); // FACTORY로부터 Movie 객체를 받아서 
		return anything.getFee();  // 사용한다.
	}
}
```
> Theme2
- 도메인 모델은 단지 시작점에 불과하다. 따라서 어떤 행동을 추가하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않다면 ‘순수한 가공물’을 추가하여 책임을 할당할 수도 있다.
- 실제로 애플리케이션 내에는 인공적으로 창조한 객체들이 도메인 개념을 반영하는 객체들보다 오히려 더 많은 비중을 차지하는 것이 일반적이다! 인상깊음 -> 너무 도메인 모델에 집착할 필요는 없구나!

>Theme3
- 의존성 주입 : 사용하는 객체가 아닌 외부의 독립적인 객체로 부터 인스턴스를 전달받음으로써 의존성을 해결하는 방법
- 컴파일타임 의존성과 런타임 의존성의 차이를 해소하기 위한 메커니즘이다
  - 생성자 주입
  - setter 주입
  - 메서드 주입
- SERVICE LOCATOR 패턴으로 의존성을 해결하는 방법도 있지만 이는 퍼블릭 인터페이스에서 의존성을 숨기기 때문에 컴파일 시점에서 문제를 발견하기 어렵게 한다
- 클래스의 퍼블릭 인터페이스 만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드

>Theme3
- 의존성 역전 : 전통적인 소프트웨어 개발 방법에서의 상위 모듈이 하위 모듈에 의존하는 모습을 역전시킴
- 상위 클래스가 하위 클래스에 의존하면 안된다. 상위 비지니스 로직을 가진 클래스의 변경에 하위 클래스가 영향을 받는 것은 허용되지만 그 반대는 있어서는 안된다
- 이를 해결하기 위해 상위 클래스, 하위 클래스 모두 추상화(인터페이스 등)에 의존하도록 하는 것이다
- 의존의 방향성은 구체 -> 추상 이지 추상 -> 구체 가 아니다
- 이를 위해서는 전통적인 방식으로 클래스와 인터페이스를 서로 다른 모듈로 다루던 것을 둘을 묶어 하나의 모듈(클라이언트 모듈)로 하고, 인터페이스의 세부 구현을 다른 모듈(서버 묘듈)로 유지함으로써 인터페이스의 소유권 역시 역전시켜야 한다 -> 이를 통해 클래스는 특정한 컨텍스트로부터 완벽하게 독립됨
  => 아직 모듈의 개념과 사용이 익숙하지 않다. 책 후반부의 모듈 부분을 자세하게 봐야겠다.


# Chapter 10
- 상속 : 차이에 의한 프로그래밍

>Theme1
- 중복 코드의 단점 : 코드를 수정하는데 필요한 노력을 몇 배로 증가시킴
  - 이와 관련해서 2학년 자료구조 과제 중 사다리 게임 만들기가 있었는데 그때 받았던 피드백 중에
    중복 코드를 함수로 만들어서 중복을 제거하라는 것이었는데, 이제 왜 그런 피드백을 받았는지 알 것
    같다!!
- DRY원칙 : Don’t Repeat Yourself
- 중복된 코드는 새로운 중복 코드를 부른다 -> 기회가 생길때마다 코드를 DRY하게 만들기 위해 노력해라
- 휴대폰 요금 실습에서 일반 요금과 심야 할인 요금의 중복 코드를 제거하는 방법으로는 타입 코드 필드를 추가하는 것인데 이는 간단하지만 클래스의 응집도를 낮추고, 결합도를 높인다! -> 유연하지 않음
- 하지만 실제로 상속으로도 구현해보면 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 하고, 부모 클래스의 가정에 대해서도 이해해야 한다.
  따라서 깊은 상속 계층을 하나씩 내려갈때마다 이해하기 어려운 가정과 마주할 수도 있고, 이는 강한 결합도를 의미하고 코드를 수정하기 어렵게 만든다!
- 너무 강하게 결합된 상속은 새로운 로직을 추가할때 중복 코드가 발생할 수 있다
  - 실습에서 세금을 부과하는 로직을 추가할때 부모클래스 뿐만 아니라 자식 클래스에도 유사한 코드	  가 추가되는 문제가 발생함
- 정리하자면 자식클래스에서의 super 참조는 두 클래스를 강하게 결합시키고, 많은 문제를 야기한다
> 취약한 기반 클래스 문제 : 자식클래스가 부모클래스의 변경에 취약해지는 현상

>Theme2
- 불필요한 인터페이스 상속으로 인해 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있음을 확인함 : Vector <- Stack, Hashtable <- Properties
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 예상치 못한 부모클래스의 사용 방법에 자식 클래스가 결합될 수 있다. : 책에서 되게 기억에 남을 예시를 보았다 -> 부모 클래스의 add 메서드를 count를 같이 키우는 메서드를 오버라이딩 했는데, addAll 메서드에도 카운트를 키우도록 했다. 이때, 부모의 addAll은 내부적으로 add를 호출하고, 따라서 addAll을 하면 결과적으로 카운트가 두 배로 올라가는 문제가 발생함
- 상속을 통해 부모 클래스와 자식 클래스는 강한 결합도를 가지게 된다. 이때, 두 클래스를 영원히 변경하지 않거나 두 클래스를 동시에 변경하는 것 중에 하나를 선택해야만 하는 문제를 가진다.

>Theme3
- 코드 중복을 제거하기 위한 상속을 할 때 고려해야 할 점
  - 중복 코드 안에서 차이점을 별도의 메서드로 추출한다
  - 중복 메서드들을 가지는 추상 클래스를 만들어서 기존의 부모, 자식 클래스가 해당 클래스를 상속
  - 결국 상위 클래스에는 중복내용들과 차이의 추상화가 남고, 하위 클래서에서 이를 구현함으로써
    중복을 해결한다
> 결국 상속 계층 안의 클래스들은 구현이 아닌 추상화에 의존해야 한다
- 메서드 구현에 대한 결합은 추상 메서드를 이용해 해결했다. 그럼에도 불구하고 아직 인스턴스 변수 변경이 야기하는 잠재적인 부작용은 아직 남아있다
- 이를 해결하기 위해 코드 중복을 해결할 수 있는 우아한 방법 ‘합성’을 공부한다


# Chapter 11
- 합성

>Theme1
- 상속과 합성의 차이점은 두 클래스 사이의 의존성이 상속은 컴파일 타임에 합성은 런타임에 해결된다
- 상속 : is-a 관계 , 합성 : has-a 관계
- 상속은 불가피하게 구현에 의존한다 (부모 클래스의 내부 구현에 대해 상세하게 알아야 한다)
- 합성은 내부에 포함되는 객체의 구현이 아니라 퍼블릭 인터페이스에 의존한다
- 앞서 살펴본 상속의 문제
  - 불필요한 인터페이스 상속 문제 -> 부적합한 부모 클래스의 오퍼레이션 상속됨
  - 메서드 오바라이딩의 오작용 문제 - 포워딩으로 해결한다!
  - 부모 클래스와 자식 클래스의 동시 수정 문제
- 이를 해결하기 위해 상속 -> 합성으로 바꾸자! : 상속 관계를 없애고 부모클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하자!

>Theme2
- 작은 기능들을 조합해 더 큰 기능을 수행하는 객체를 만들어야 하는 경우에 상속은 두 가지 문제를 야기
  1. 하나의 기능을 추가하거나 수정하기 위해 많은 수의 클래스를 추가하거나 수정해야함 - 클래스폭발
  2. 단일 상속만 지원하는 경우 상속으로 인해 오히려 중복 코드 늘어남
- 상속 관계는 컴파일타임에 결정되고 고정되기 때문에 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야하는 ‘클래스폭발’문제가 발생한다

>Theme3
- 8장에서 말했듯이 컴파일타임 의존성과 런타임 의존성의 거리가 멀수록 설계가 유연해진다. 따라서 상속은 유연하지 못한 설계 문제를 야기하고, 합성은 런타임에 동적으로 변경할 수 있으므로 유연한 설계가 가능하다
- 코드를 재사용하면서도 건전한 결합도를 유지하는 방법은 상속이 아니라 합성을 사용하는 것이다
- 상속은 구현을 재사용 하는데 반해 합성은 인터페이스를 재사용 하므로 결합도가 훨씬 낮다
- 하지만 상술한 상속의 단점은 구현의 상속에 국한되는 문제이므로 다음 장에서 인터페이스 상속에 대해 알아보자!

>Theme4
- 코드재사용을 위한 방법에는 ‘믹스인’이라는 방법이 있다. 상속과 합성의 특성을 모두 보유한다
- 코드를 다른 코드 안에 유연하게 섞어넣는 방식이다
- 추후에 더 자세히 알아보자! (아래에 추가)
> 믹스인 장점
>> 1. 여러 클래스가 공용기능들을 사용할 수 있게 하는 다중상속의 메카니즘을 제공하지만, 다중상속의 복잡한 의미론은 제거할 수 있다.
>> 2. 코드 재사용성 : 믹스인은 프로그래머가 서로 다른 클래스간에 기능을 공유하고자 할 때 유용한다. 동일한 코드를 반복해서 작성하는 대신 공통기능을 믹스인으로 그룹화하고 이 기능을 필요로하는 다른 클래스들에 추가할 수 있다.
>> 3. 믹스인은 부모클래스의 모든 기능을 상속하지 않고 필요로 하는 기능만 상속하고 사용할 수 있다


# Chapter12 - 다형성 ⭐⭐⭐
### 개인적으로 이 책에서 가장 뜻깊게 읽은 챕터!

> Theme1
- 11장에서 살펴본 바와 같이 코드의 재사용을 목적으로 한 상속은 부작용이 있다
- 상속은 타입 계층을 구조화하기 위해 사용해야 한다 => 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서이다
- 다형성 : 많은 형태를 가질 수 있는 능력 => 그 중에서도 객체지향에서는 ‘포함 다형성’ : 메시지가 동일하더라도 수신하는 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력

>Theme2
- 부모 클래스와 자식 클래스의 메서드의 시그니처가 같다 : 메서드 오버라이딩 : 부모 메서드가 가려짐
- 부모 클래스와 자식 클래스의 메서드 이름은 같지만 시그니처가 다르다 : 메서드 오버로딩
- 다형성을 구현하기 위한 수단으로서의 상속은 메시지 위임이 핵심이다. 이때 언어에 따라서 상속이 아닌 다른 방식으로 메시지 위임을 지원하기도 한다
- 자바에서는 메서지 오버로딩은 부모 메서드와 자식 메서드가 공존할 수 있지만 c++에서는 ‘이름 숨기기’로 인해 오버로딩된 메서드도 자식 메서드가 부모 메서드를 가린다

> Theme3 ⭐⭐⭐
- 자식 클래스로부터 부모 클래스로 메시지에 맞는 메서드를 찾아나선다
- ‘현재 클래스의 메서드를 호출하는 것’, ‘현재 객체에게 메시지를 전송하는 것’ 의 차이 : ‘self 참조’때문
- 동적 메서드 탐색은 self참조에 의해 진행된다. 메시지를 수신받은 객체를 self로 하여 Object에 닿기까지 부모 클래스를 탐색하며 메시지에 알맞은 메서드를 실행한다. 이때 탐색 경로의 시작인 self는 고정되기 때문에 메시지를 처리하기 위해 수행되는 메서드에서 다시 보내는 메시지의 탐색 경로의 시작은 self이다. 이를 유의하지 않으면 원치않는 실행 결과를 마주할 수도 있다
- super의 경우 메시지를 전송하는 클래스의 부모 클래스부터 시작해서 메시지에 맞는 메서드를 찾는다
  => 단순히 부모클래스의 특정 메서드를 실행한다는 개념이 아니다!
>> 상속을 self참조변수를 공유하는 것이라고 볼 수 있다!  : 언제나 자식클래스를 가리키는 self참조변수 이런 개념을 위임 이라고 한다  
>>이와 대비되는 개념인 포워딩은 self참조를 전달하지 않는데 이는 메시지를 self가 가리키는 최초의 객체에게 전달할 필요없이 단순히 코드를 재사용하고 싶을 때 적용하는 개념이다 : 우리가 앞 장에서 상속의 단점을 공부할때 사용되던 상속의 목적이 포워딩이다
> ### ⭐ 정리하자면 상속의 본질은 위임이라 할 수 있고, 이는 자신이 정의하지 않거나 처리할 수 없는 속성 또는 메서드의 탐색 과정을 다른 객체로 이동시키기 위해 사용한다는 것이다!